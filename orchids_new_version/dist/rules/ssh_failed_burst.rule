// DIFF_TIME : Maximum time gap between two events
// THRESH : Number of chained events to detect
#define DIFF_TIME _CTIME(53)
#define THRESH 100

#define TIME_FIELD .syslog.time
#define AGGR_INIT $source = .sshd.src_ip
#define AGGR_VARS $source
#define AGGR_COND .sshd.src_ip == $source
#define CONDITION .sshd.action == "Failed"

#define ALERT_ACTION ;

/*
 * SSH bruteforce detection : Detect bursts (rapid ssh failures) from the same source
 * To use on syslog logs
 * Detects chains of events (minimum THRESH chained events)
 * Events must be separated by DIFF_TIME time gap at most
 * Here a single rule instance is started and stay for a specific source ip
 *
 * [IPS] To block the attacker in real time. See rule anti_ssh_scan.rule
 *
 * XXX ===> Need to check what happens if events are not in the right order
 */
rule ssh_failed_burst synchronize (AGGR_VARS)
    // all rule instances with the same AGGR_VARS are merged
{
  state init
  {
    expect (CONDITION)
      goto start;
  }

  state start! {
    $total = 0;
    $nb_burst = 0;
    AGGR_INIT;
    goto first;
  }

  state first!
  {
    $total_begin = TIME_FIELD;
    $count = 0;
    $begin = TIME_FIELD;
    $last = TIME_FIELD;

    $diff_begin = _CTIME(0);
    $diff_last = _CTIME(0);
    goto loop;
  }

  state loop!
  {
    $count = $count + 1;
    if ($begin != TIME_FIELD)
    {
      $diff_begin = TIME_FIELD - $begin;
      $diff_last = TIME_FIELD - $last;
    }
    $last = TIME_FIELD;

    expect ((CONDITION) && (AGGR_COND))
      goto proceed;
    expect (TIME_FIELD > $last+DIFF_TIME)
      goto stop;
  }

  state proceed! {
    case ($count>=THRESH) goto alert;
    else case ($diff_last >= DIFF_TIME) goto stop;
    else goto loop;
  }


  state alert!
  {
    print_string ("Alert: Burst ==> More than ");
    print_string (str_from_uint (THRESH));
    print_string (". Count=");
    print_string (str_from_uint ($count));
    print_string (". Source : ");
    print_string (str_from_ipv4($source));
    print_string (". Burst started at ");
    print_string (str_from_ctime($begin));
    print_string ("\n");

    $total = $total + $count;
    $nb_burst = $nb_burst + 1;
    goto first;
  }

  state stop!
  {
    if ($nb_burst > 0)
    {
      print_string ("Alert : Multiple burst : ");
      print_string (str_from_uint($nb_burst));
      print_string (" consecutive bursts. Total : ");
      print_string (str_from_uint($count));
      print_string (". Bursts started at ");
      print_string (str_from_ctime($total_begin));
      print_string (" Source : ");
      print_string (str_from_ipv4($source));
      print_string ("\n");
    }

    // Here we start a new burst detection by going back to the first state.
    goto first;
  }

}
