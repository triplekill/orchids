/*
The pid tracker.
*/

#include "linux64syscall.h"

rule pidtrack
{

  state init
  {
    expect (.auditd.syscall==SYS_fork)
      goto newpid;

    expect (.auditd.syscall==SYS_vfork)
      goto newpid;

    expect (.auditd.syscall==SYS_clone)
      goto newpid;
  }

  state newpid! {
    $pid = .auditd.exit;
    $uid = .auditd.euid;
    $gid = .auditd.egid;

    goto wait;
  }

  state wait!
  {
    expect (.auditd.pid == $pid &&
        .auditd.euid != $uid)
      goto alert;

    expect (.auditd.pid == $pid &&
        .auditd.egid != $gid)
      goto alert;

    expect (.auditd.pid == $pid &&
        .auditd.syscall == SYS_execve)
      goto update_uid_gid;

    expect (.auditd.pid == $pid &&
        .auditd.syscall == SYS_setresuid)
      goto update_setuid;

    expect (.auditd.pid == $pid &&
        .auditd.syscall == SYS_setreuid)
      goto update_setuid;

    expect (.auditd.pid == $pid &&
        .auditd.syscall == SYS_setgid)
      goto update_setgid;

    expect (.auditd.pid == $pid &&
        .auditd.syscall == SYS_exit)
      goto end;

    expect (.auditd.syscall == SYS_kill &&
        .auditd.varzero == $pid &&
        .auditd.varone == 9)
      goto end;
  }

  state update_uid_gid!
  {
    $uid = .auditd.euid;
    $gid = .auditd.egid;

    goto wait;
  }

  state update_setuid!
  {
    $uid = .auditd.varone; /* a1 field contains new euid (a0=new ruid) */

    goto wait;
  }

  state update_setgid!
  {
    $gid = .auditd.varzero;

    goto wait;
  }

  state alert!
  {

    print_string ("Alert report :\n");

    $str = "Attack perpetrated by $uid=" + str_from_uint($uid);
    print_string ($str);
    print_string ("\n");
    report();


    $str = "ssh client 'USER=`cut -d : -f 1,3 /etc/passwd | grep "
    + str_from_uint($uid) +
    " | cut -d : -f 1`; echo You have been kicked out by OrchIDS... | write $USER; kill -9 `ps -u $USER -o pid=`; chsh -s /sbin/nologin $USER' >/dev/null 2>/dev/null &";
    system($str);
  }

  state end!
  {
    /* all went well */
  }
}
