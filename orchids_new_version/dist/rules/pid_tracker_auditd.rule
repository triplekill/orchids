/*
The pid tracker.
*/

#include "linux64syscall.h"

/*** Needed configuration:
 *** auditctl -a always,exit -F arch=x86_64 -S clone,execve,exit,kill,setuid,setgid,setreuid,setregid,setresuid,setresgid
 ***/

rule pidtrack synchronize($pid)
{

  state init
  {
    expect (.auditd.syscall==SYS_clone ||
	    .auditd.syscall==SYS_fork ||
	    .auditd.syscall==SYS_vfork)
      goto newpid;
  }

  state newpid! {
    $pid = .auditd.exit;
    $uid = .auditd.euid;
    $gid = .auditd.egid;

    goto wait;
  }

  state wait!
  {
    expect (.auditd.pid == $pid &&
	    .auditd.syscall == SYS_execve &&
	    (.auditd.uid != .auditd.euid || .auditd.gid != .auditd.egid) && /* hack */
	    .auditd.success == "yes")
      goto update_uid_gid;

    expect (.auditd.pid == $pid &&
	    (.auditd.syscall == SYS_setresuid ||
	     .auditd.syscall == SYS_setreuid ||
	     .auditd.syscall == SYS_setuid) &&
	    .auditd.success == "yes")
      goto update_setuid;

    expect (.auditd.pid == $pid &&
	    (.auditd.syscall == SYS_setresgid ||
	     .auditd.syscall == SYS_setregid ||
	     .auditd.syscall == SYS_setgid) &&
	    .auditd.success == "yes")
      goto update_setgid;

    expect (.auditd.pid == $pid &&
	    .auditd.syscall == SYS_exit)
      goto end;

    expect (.auditd.syscall == SYS_kill &&
	    .auditd.a0 == $pid &&
	    .auditd.a1 == 9)
      goto end;

    /* We now catch any other auditd event (at least from those
       reported by audispd --- check with 'auditctl -l').
       If the current $pid runs with an unexpected $uid or $gid,
       then raise an alert.
       It would seem sensible to put the following checks before,
       and not after, the checks above --- so that even calls
       to exec(), setresuid(), etc., done with the wrong rights
       would be caught.  That does not work, because those calls
       return the rights that are obtained *after* the call, not
       those that preexisted the call.
    */

    expect (.auditd.pid == $pid &&
	    (.auditd.euid != $uid || .auditd.egid != $gid))
      goto alert;
  }

  state update_uid_gid!
  {
    $uid = .auditd.euid;
    $gid = .auditd.egid;

    goto wait;
  }

  state update_setuid!
  {
  case (.auditd.egid != $gid) goto alert;
  else goto update_uid_gid;
  }

  state update_setgid!
  {
  case (.auditd.euid != $uid) goto alert;
  else goto update_uid_gid;
  }

  state alert!
  {

    print_string ("Alert report :\n");

    print_string ("Attack perpetrated by uid=");
    print_string (str_from_uint($uid));
    print_string (", now ");
    print_string (str_from_uint(.auditd.euid));
    print_string (", gid=");
    print_string (str_from_uint($gid));
    print_string (", now ");
    print_string (str_from_uint(.auditd.egid));
    print_string (", pid=");
    print_string (str_from_uint($pid));
    print_string ("\n");
    report();

#ifdef DEACTIVATED_RESPONSE
    $str = "ssh client 'USER=`cut -d : -f 1,3 /etc/passwd | grep "
    + str_from_uint($uid) +
    " | cut -d : -f 1`; echo You have been kicked out by OrchIDS... | write $USER; kill -9 `ps -u $USER -o pid=`; chsh -s /sbin/nologin $USER' >/dev/null 2>/dev/null &";
    system($str);
#endif
  }

  state end!
  {
    /* all went well */
  }
}
