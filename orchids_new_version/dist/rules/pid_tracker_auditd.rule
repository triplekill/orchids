/*
The pid tracker.
*/

#include "linux64syscall.h"

rule pidtrack
{

  state init
  {
    expect (.auditd.syscall==SYS_fork)
      goto newpid;

    expect (.auditd.syscall==SYS_vfork)
      goto newpid;

    expect (.auditd.syscall==SYS_clone)
      goto newpid;
  }

  state newpid! {
    $pid = .auditd.exit;
    $uid = .auditd.euid;
    $gid = .auditd.egid;

    goto wait;
  }

  state wait!
  {
    expect (.auditd.pid == $pid &&
        .auditd.syscall == SYS_execve &&
	.auditd.success == "yes")
      goto update_uid_gid;

    expect (.auditd.pid == $pid &&
        .auditd.syscall == SYS_setresuid &&
	.auditd.success == "yes")
      goto update_setuid;

    expect (.auditd.pid == $pid &&
        .auditd.syscall == SYS_setreuid &&
	.auditd.success == "yes")
      goto update_setuid;

    expect (.auditd.pid == $pid &&
        .auditd.syscall == SYS_setgid &&
	.auditd.success == "yes")
      goto update_setgid;

    expect (.auditd.pid == $pid &&
        .auditd.syscall == SYS_exit)
      goto end;

    expect (.auditd.syscall == SYS_kill &&
        .auditd.a0 == $pid &&
        .auditd.a1 == 9)
      goto end;

    /* We now catch any other auditd event (at least from those
       reported by audispd --- check with 'auditctl -l').
       If the current $pid runs with an unexpected $uid or $gid,
       then raise an alert.
       It would seem sensible to put the following checks before,
       and not after, the checks above --- so that even calls
       to exec(), setresuid(), etc., done with the wrong rights
       would be caught.  That does not work, because those calls
       return the rights that are obtained *after* the call, not
       those that preexisted the call.
    */

    expect (.auditd.pid != $pid || .auditd.euid != $uid)
      goto alert;
  }

  state update_uid_gid!
  {
    $uid = .auditd.euid;
    $gid = .auditd.egid;

    goto wait;
  }

  state update_setuid!
  {
    $uid = .auditd.a1; /* a1 field contains new euid (a0=new ruid) */

    goto wait;
  }

  state update_setgid!
  {
    $gid = .auditd.a0;

    goto wait;
  }

  state alert!
  {

    print_string ("Alert report :\n");

    $str = "Attack perpetrated by $uid=" + str_from_uint($uid);
    print_string ($str);
    print_string ("\n");
    report();

#ifdef DEACTIVATED_RESPONSE
    $str = "ssh client 'USER=`cut -d : -f 1,3 /etc/passwd | grep "
    + str_from_uint($uid) +
    " | cut -d : -f 1`; echo You have been kicked out by OrchIDS... | write $USER; kill -9 `ps -u $USER -o pid=`; chsh -s /sbin/nologin $USER' >/dev/null 2>/dev/null &";
    system($str);
#endif
  }

  state end!
  {
    /* all went well */
  }
}
