/**
 ** @file mod_clocks.c
 ** A module for handling clock uncertainty.
 ** 
 ** @author Julien OLIVAIN <julien.olivain@lsv.ens-cachan.fr>
 ** 
 ** @version 0.1.0
 ** @ingroup modules
 ** 
 ** @date  Started on: Mon Dec 01 00:57:32 2003
 ** @date Last update: Mon Nov 14 14:37:50 2005
 **/

/*
 * See end of file for LICENSE and COPYRIGHT informations.
 */

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

#include "orchids.h"

#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include <sys/time.h>
#include <math.h>
#include <string.h>

#include "safelib.h"
#include "strhash.h"

typedef struct timeval timeval_t;
#ifdef USE_DOUBLE
typedef double timefloat_t;
typedef double prob_t;
#else
typedef float timefloat_t;
typedef float prob_t;
#endif

typedef unsigned long sequence_t;

typedef struct clock_s clock_t;
struct clock_s {
  char *name;
  timefloat_t prec;
  timefloat_t sync;
};

typedef struct clocktime_s clocktime_t;
struct clocktime_s {
  clock_t *clock;
  sequence_t seq;
  timefloat_t time;
};

typedef struct clockctx_s clockctx_t;
struct clockctx_s {
  strhash_t *clocks;
};

void
clock_add_float(clockctx_t *ctx, 
		char *name, 
		timefloat_t prec, 
		timefloat_t sync);


#define TIMER_ADD(r, a, b) \
  do { \
    (r)->tv_usec = ((a)->tv_usec + (b)->tv_usec) % 1000000; \
    (r)->tv_sec  =  (a)->tv_sec +  (b)->tv_sec \
                   + (((a)->tv_usec + (b)->tv_usec) / 1000000); \
  } while (0)

#define TIMER_SUB(r, a, b) \
  do { \
    if ((a)->tv_usec < (b)->tv_usec) { \
        (r)->tv_usec = 1000000 + (a)->tv_usec - (b)->tv_usec; \
        (r)->tv_sec = (a)->tv_sec - (b)->tv_sec - 1; \
      } else { \
        (r)->tv_usec = (a)->tv_usec - (b)->tv_usec; \
        (r)->tv_sec  = (a)->tv_sec  - (b)->tv_sec; \
      } \
  } while (0)

#define TIMER_TO_FLOAT(t) ( (t)->tv_sec + ((t)->tv_usec / 1000000.0 ) )

#ifdef USE_DOUBLE
#define FLOAT_TO_TIMER(t, f) (t)->tv_usec = 1000000.0 * modf((f), &(t)->tv_sec)
#else
#define FLOAT_TO_TIMER(t, f) \
do { \
  timefloat_t i; \
  (t)->tv_usec = 1000000.0 * modff((f), &i); \
  (t)->tv_sec = i; \
  } while (0)
#endif

void
clock_add(clockctx_t *ctx, char *name, timeval_t *prec, timeval_t *sync)
{
  timefloat_t fprec;
  timefloat_t fsync;

  fprec = TIMER_TO_FLOAT(prec);
  fsync = TIMER_TO_FLOAT(sync);

  clock_add_float(ctx, name, fprec, fsync);
}

void
clock_add_float(clockctx_t *ctx, char *name, timefloat_t prec, timefloat_t sync)
{
  clock_t *clock;

  clock = Xzmalloc(sizeof (clock_t));
  clock->name = name;
  clock->prec = prec;
  clock->sync = sync;

  strhash_add(ctx->clocks, clock, name);
}

#define MIN(a, b) ((a) < (b)) ? (a) : (b)
#define MAX(a, b) ((a) > (b)) ? (a) : (b)

#define CLOCKTIME_MIN_MAX(min, max, ct) \
 \
  do { \
    timefloat_t t, t_prec, sync; \
\
    t = (ct)->time; \
    t_prec = t + (ct)->clock->prec; \
    sync = (ct)->clock->sync; \
    (min) = MIN(t, t_prec) - sync; \
    (max) = MAX(t, t_prec) + sync; \
\
  } while (0)


prob_t
prob_is_before(clockctx_t *ctx, clocktime_t *t1, clocktime_t *t2)
{
  timefloat_t t1_min;
  timefloat_t t1_max;
  timefloat_t t2_min;
  timefloat_t t2_max;
  prob_t p;

  CLOCKTIME_MIN_MAX(t1_min, t1_max, t1);
  CLOCKTIME_MIN_MAX(t2_min, t2_max, t2);

  /* case 1 */
  if (t2_max < t1_min)
    return (0.0);

  /* case 2 */
  if (t1_max < t2_min)
    return (1.0);

  /* case 3 */
  if ((t2_min < t1_min) &&
      (t1_min <= t2_max) &&
      (t2_max < t1_max)) {
    p = (  (0.5 * t2_max * t2_max)
         + (0.5 * t1_min * t1_min)
         - (t2_max * t1_min) )
      / ( (t1_max - t1_min) * (t2_max - t2_min));

    return (p);
  }

  /* case 4 */
  if ((t1_min <= t2_min) &&
      (t2_min < t2_max) &&
      (t2_max <= t1_max)) {
    p = (t2_min - t1_min) / (t1_max - t1_min);
    p += (   (0.5 * t2_max * t2_max)
           + (0.5 * t2_min * t2_min)
           - (t2_max * t2_min) )
         / ( (t1_max - t1_min) * (t2_max - t2_min) );

    return (p);
  }

  /* case 5 */
  if ((t1_min < t2_min) &&
      (t2_min <= t1_max) &&
      (t1_max < t2_max)) {
    p = (t2_min - t1_min) / (t1_max - t1_min);
    p += (   (t2_max * t1_max)
           - (t2_max * t2_min)
           + (0.5 * t2_min * t2_min)
           - (0.5 * t1_max * t1_max) )
         / ( (t1_max - t1_min) * (t2_max - t2_min) );

    return (p);
  }

  /* case 6 */
  if ((t2_min <= t1_min) &&
      (t1_min < t1_max) &&
      (t1_max <= t2_max)) {
    p = (  (  t2_max * t1_max)
           - (t2_max * t1_min)
           + (0.5 * t1_min * t1_min)
           - (0.5 * t1_max * t1_max) )
      / ( (t1_max - t1_min) * (t2_max - t2_min) );

    return (p);
  }

  return (-1.0); /* Shouldn't not append */
}

prob_t
prob_is_after(clockctx_t *ctx, clocktime_t *t1, clocktime_t *t2)
{
  return ( prob_is_before(ctx, t2, t1) );
}

prob_t
prob_is_before_fast(clockctx_t *ctx, clocktime_t *t1, clocktime_t *t2)
{
  timefloat_t t1_min;
  timefloat_t t1_max;
  timefloat_t t2_min;
  timefloat_t t2_max;
  prob_t p;

  CLOCKTIME_MIN_MAX(t1_min, t1_max, t1);
  CLOCKTIME_MIN_MAX(t2_min, t2_max, t2);

  /* case 1 */
  if (t2_max < t1_min)
    return (0.0);

  /* case 2 */
  if (t1_max < t2_min)
    return (1.0);

  p = (t2_max - t1_min) / (t1_max - t1_min + t2_max - t2_min);

  return (p);
}

prob_t
prob_is_after_fast(clockctx_t *ctx, clocktime_t *t1, clocktime_t *t2)
{
  return ( prob_is_before_fast(ctx, t2, t1) );
}

int
make_clocktime(clockctx_t *ctx,
               clocktime_t *clocktime,
               timeval_t *time,
               sequence_t seq,
               char *clock_name)
{
  clock_t *clock;

  clock = strhash_get(ctx->clocks, clock_name);
  if (clock == NULL)
    return (-1);
  clocktime->clock = clock;
  clocktime->seq = seq;
  clocktime->time = TIMER_TO_FLOAT(time);

  return (0);
}

int
make_clocktime_float(clockctx_t *ctx,
                     clocktime_t *clocktime,
                     timefloat_t time,
                     sequence_t seq,
                     char *clock_name)
{
  clock_t *clock;

  clock = strhash_get(ctx->clocks, clock_name);
  if (clock == NULL)
    return (-1);
  clocktime->clock = clock;
  clocktime->seq = seq;
  clocktime->time = time;

  return (0);
}


clockctx_t *
new_clocks_ctx(void)
{
  clockctx_t *ctx;

  ctx = Xmalloc(sizeof (clockctx_t));
  ctx->clocks = new_strhash(1021);

  return (ctx);
}

void
parse_config(clockctx_t *ctx, char *file)
{
  char buffer[4096];
  char clock_name[256];
  timefloat_t prec;
  timefloat_t sync;
  FILE *fp;
  int ret;

  fp = Xfopen(file, "r");
  while (!feof(fp)) {
    ret = fscanf(fp, "%256s %f %f", &clock_name, &prec, &sync);
    if (ret == 3) {
      clock_add_float(ctx, strdup(clock_name), prec, sync);
    }
  }
}

void
main_loop(clockctx_t *ctx)
{
  char buffer[4096];
  char clock1[256], clock2[256];
  sequence_t seq1, seq2;
  timefloat_t t1, t2;
  int test;
  int ret;
  clocktime_t ct1, ct2;
  prob_t p;

  while (fgets(buffer, sizeof (buffer), stdin)) {
    clock1[0] = '\0';
    clock2[0] = '\0';
    ret = fscanf(stdin, "(%256s %lu %f) %c (%256s %lu %f)",
           clock1, &seq1, &t1,
           &test,
           clock2, &seq2, &t2);
    if (ret == 7) {
      printf("clock1=%s seq1=%lu t1=%f\n%c\nclock2=%s seq2=%lu t2=%f\n",
             clock1, seq1, t1,
             test,
             clock2, seq2, t2);
      if (make_clocktime_float(ctx, &ct1, t1, seq1, clock1) == -1) {
        fprintf(stderr, "clocktime error\n");
        continue ;
      }
      if (make_clocktime_float(ctx, &ct2, t2, seq2, clock2) == -1) {
        fprintf(stderr, "clocktime error\n");
        continue ;
      }
      if ((char)test == '<')
        p = prob_is_before(ctx, &ct1, &ct2);
      else if ((char)test == '>')
        p = prob_is_after(ctx, &ct1, &ct2);
      else {
        fprintf(stderr, "< or > expected (%c)\n", test);
        continue ;
      }
      printf("p(t1 %c t2)=%10.8f\n", test, p);
    }
    else {
      fprintf(stderr, "syntax error\n");
    }
  }
}

static void
add_clock(orchids_t *ctx, mod_entry_t *mod, config_directive_t *dir)
{
  config_directive_t *clock_dir;

  for (clock_dir = dir->first_child; clock_dir; clock_dir = clock_dir->next) {
    if (!strcmp(clock_dir->directive, "Precision")) {
    }
    else if (!strcmp(clock_dir->directive, "Synchronization")) {
    }
  }

}

static void *
clocks_preconfig(orchids_t *ctx, mod_entry_t *mod)
{
}

static mod_cfg_cmd_t clocks_config_commands[] = 
{
  { "<clock", add_clock, "Add a new clock definition" },
  { NULL, NULL, NULL }
};

input_module_t mod_generic = {
  MOD_MAGIC,
  ORCHIDS_VERSION,
  "clocks",
  "LICENSE",
  NULL,
  clocks_config_commands,
  clocks_preconfig,
  NULL,
  NULL
};







#if 0

int
main(int argc, char *argv[])
{
  clockctx_t *ctx;
  clocktime_t ct1, ct2;
  int i;
  prob_t p;

  if (argc != 2) {
    fprintf(stderr, "usage %s <configfile>\n", argv[0]);
    exit(EXIT_FAILURE);
  }

  ctx = new_clocks_ctx();
  parse_config(ctx, argv[1]);

/*   make_clocktime_float(ctx, &ct1, 10.123, "host1-kernel"); */
/*   make_clocktime_float(ctx, &ct2, 10.2, "host2-kernel"); */

  prob_is_before_fast(ctx, &ct1, &ct2);

  main_loop(ctx);

  return (0);
}

#endif
